Enemies	Datas.h	/^typedef vector<Enemy> Enemies;$/
LoadLevel	Loader.cpp	/^const LevelData Loader::LoadLevel()$/
LoadStage	Loader.cpp	/^const StageData Loader::LoadStage()$/
MapData	Datas.h	/^typedef vector<vector<char>> MapData;$/
Mmain.cpp	main.cpp	/^int main()$/
NODE	Simulator.cpp	/^	typedef pair<pair<int,int>, Point> NODE;$/
Points	Datas.h	/^typedef vector<Point> Points;$/
Solver	Solver.cpp	/^Solver::~Solver()$/
Task	Datas.h	/^	Task() {}$/
Towers	Datas.h	/^typedef vector<Tower> Towers;$/
addTask	Task.cpp	/^void TaskList::addTask(const Task &task)$/
attack	Simulator.cpp	/^int ActTower::attack()$/
build	Solver.cpp	/^bool Solver::build(const Task &task)$/
buy	Solver.cpp	/^bool Wallet::buy(const Task &task, Towers *towers)/
calcCost	Solver.cpp	/^int Wallet::calcCost(int kind, int oldLevel, int n/
canGoal	Solver.cpp	/^bool Solver::canGoal(const MapData &fmap)$/
canMove	Simulator.cpp	/^bool Simulator::canMove(const MapData &route, cons/
check	Solver.cpp	/^bool Wallet::check(const Task &task, const Towers /
createDistMap	main.cpp	/^vector<vector<int>> MazeSolver::createDistMap(cons/
createMap	Simulator.cpp	/^const MapData Simulator::createMap(const MapInfo &/
createMaze	main.cpp	/^const Point MazeSolver::createMaze()$/
createOnlyGoal	main.cpp	/^void MazeSolver::createOnlyGoal()$/
createRouteMap	Simulator.cpp	/^const MapData Simulator::createRouteMap(const MapD/
createTask	main.cpp	/^Task MazeSolver::createTask(const Point &p)$/
damage	Simulator.cpp	/^bool ActEnemy::damage(const Tower &data)$/
dead	Simulator.cpp	/^ActEnemy::ActEnemy(int id, const Enemy &enemy) : d/
debugPrint	main.cpp	/^void MazeSolver::debugPrint(const vector<vector<in/
enemies	Datas.h	/^	LevelData(int life, int money, const Towers &towe/
enterEnemy	Simulator.cpp	/^void ActTower::enterEnemy(int id, int time, const /
findGoal	main.cpp	/^Point MazeSolver::findGoal()$/
getPower	Datas.h	/^	inline int getPower() const$/
getR	Datas.h	/^	inline int getR() const$/
getSpeed	Datas.h	/^	inline int getSpeed() const$/
getTargetId	Simulator.cpp	/^int ActTower::getTargetId()$/
goals	Datas.h	/^		: width(width), height(height), data(data), star/
id	Simulator.cpp	/^ActTower::ActTower(int id, const Tower &tower) : d/
kill	Simulator.cpp	/^void ActEnemy::kill()$/
kind	Datas.h	/^	Task(const Point &point, int level, int kind) : p/
leaveEnemy	Simulator.cpp	/^void ActTower::leaveEnemy(int id)$/
level	Datas.h	/^	StageData(const MapInfo &map, int level) : map(ma/
m_map	Solver.cpp	/^: stage(stageData), level(levelData), wallet(level/
move	Simulator.cpp	/^void ActEnemy::move(int id)$/
output	Task.cpp	/^void TaskList::output()$/
price	Solver.cpp	/^int Wallet::price(const Task &task, const Towers &/
print	Datas.h	/^	void print() const { cout << "Point:(" << x << ",/
printMap	Solver.cpp	/^void Solver::printMap()$/
resetCounter	Simulator.cpp	/^void ActEnemy::resetCounter()$/
run	OldSolver.cpp	/^void OldSolver::run()$/
simulate	Solver.cpp	/^vector<int> Solver::simulate()$/
speed	Datas.h	/^	Enemy(const Point &point, int time, int life, int/
update	Simulator.cpp	/^int ActEnemy::update(int time)$/
upgrade	main.cpp	/^void MazeSolver::upgrade(int r, const Point &goal,/
upgradeCir	main.cpp	/^void MazeSolver::upgradeCir(const Point &o, int r)/
y	Datas.h	/^	Point() : x(0), y(0) {}$/
